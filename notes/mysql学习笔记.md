# MySQL学习笔记

## 索引

### 索引是什么

> 索引是帮助MySQL高效获取数据的数据结构。
>
> 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。

### 优势和劣势

> 优势：
>
> 1. 提高数据检索的效率，降低数据库的IO成本。
> 2. 降低数据排序的成本，降低了CPU的消耗。

> 劣势：
>
> 1. 索引也是一张表，保存了主键和索引字段，所以索引也是要占用物理空间。
> 2. 索引大大提高查询速度，同时降低更新表的速度。
> 3. 需要花时间研究建立最优秀的索引。

### 基本语法

> 创建：
>
> 1. CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
> 2. ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length));

> 删除：
>
> 1. DROP INDEX [indexName] ON mytable;

> 查看：
>
> 1. SHOW INDEX FROM table_name\G

### 哪些字段适合建索引

> 1. 主键自动创建唯一索引。
> 2. 频繁作为查询条件的字段应该创建索引。
> 3. 查询中与其他表关联的字段，外键关系建立索引。
> 4. 频繁更新的字段不适合创建索引。
> 5. Where条件里用不到的字段不创建索引。
> 6. 单键、组合索引的选择问题，在高并发下倾向创建组合索引。
> 7.  查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。
> 8. 查询中统计或者分组字段。

### 哪些不要建索引

> 1. 表记录太少。
> 2. 经常更改的表。
> 3. 数据重复且分布平均的表字段。

## Explain

### 是什么

> 使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。

### 能干嘛

> 1. 表的读取顺序
> 2. 数据读取操作的操作类型
> 3. 哪些索引可以使用
> 4. 哪些索引被实际使用
> 5. 表之间的引用
> 6. 每张表有多少行被优化器查询

### id

>  select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。

> 三种情况：
>
> 1. id相同，执行顺序由上至下。
> 2. id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。
> 3. id相同不同，同时存在。

### select_type

> 查询的类型，主要是用于区别普通查询，联合查询，子查询等复杂的查询。

> 6种：
>
> 1. SIMPLE：简单的select查询，查询中不高喊子查询或者UNION。
> 2. PRIMARY：查询中若包含任何辅助的子部分，最外层的查询则被标记。
> 3. SUBQUERY：在select或where列表中包含了子查询。
> 4. DERIVED：在from列表中包含了子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。
> 5. UNION：若第二个select出现在UNION之后，则被标记为UNION；若UNION包含在from子句的子查询中，外层select将被标记为DERIVED。
> 6. UNION RESULT：从UNION表获取结果的select。

### type

> 访问类型排列。

> 显示查询使用了何种类型，从最好到最差依次是：system>const>eq_ref>ref?range>index>ALL

> system：表只有一行记录，这是const类型的特例，平时不会出现。
>
> const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，MySQL就能将该查询转换为一个常量。
>
> eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。