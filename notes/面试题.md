# java面试题

## java中的JUC

> juc是指java中的java.util.concurrent下面的API，是java并发相关的包。

## volatile解析

> volatile是java虚拟机提供的轻量级的同步机制。
>
> volatile三大特性：
>
> 1. 保证可见性
>
>    当一个线程修改了一个volatile类型的值后，其他线程都可以及时共享到修改后的值。
>
> 2. 不保证原子性
>
>    原子性是指某一个线程做的业务是不可分割的，需要整体的完整性，要么同时成功，要么同时失败。
>
> 3. 禁止指令重排序

### 什么是JMM

> JMM是java内存模型。
>
> 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而java内存模型中规定所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间中，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过住内存来完成。

### volatile可见性实例代码

```java
public class VolatileDemo {
    public static void main(String[] args) {

        Mydata data = new Mydata();
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"线程启动-----");
            try {
                TimeUnit.SECONDS.sleep(3);
                data.update();
                System.out.println(Thread.currentThread().getName()+" upate value:"+data.number);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        while (data.number == 0) {

        }
        System.out.println(Thread.currentThread().getName()+"  main is over value:"+data.number);
    }
}

class Mydata{
    
    volatile int number = 0;

    public void update(){
        this.number = 10;
    }
}
```

### volatile不保证原子性实例代码

```java 
public class VolatileDemo {
    public static void main(String[] args) {

        Mydata data = new Mydata();
        for (int i=0;i<20;i++){
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"线程启动-----");
                for (int j=0;j<1000;j++){
                    data.add();
                }
            },"线程---"+String.valueOf(i)+"---").start();
        }
        while (Thread.activeCount() > 2) {
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+"  main is over value:"+data.number);
    }
}

class Mydata{
    volatile int number = 0;

    public void add(){
        number++;
    }

    public void update(){
        this.number = 10;
    }
}
```

> 如何解决volatile的原子性问题
>
> 1. 加 synchronized
> 2.   直接使用juc下的AtomicInteger

### volatile保证原子性案例

```java 
public class VolatileDemo {
    public static void main(String[] args) {

        Mydata data = new Mydata();
        for (int i=0;i<20;i++){
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"线程启动-----");
                for (int j=0;j<1000;j++){
                    data.add();
                    data.atomicAdd();
                }
            },"线程---"+String.valueOf(i)+"---").start();
        }
        while (Thread.activeCount() > 2) {
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+"  main is over int type value:"+data.number);
        System.out.println(Thread.currentThread().getName()+"  main is over atomicInteger type value:"+data.atomicInteger);
    }
}

class Mydata{
    volatile int number = 0;

    public void add(){
        number++;
    }

    AtomicInteger atomicInteger = new AtomicInteger();
    public void atomicAdd(){
        atomicInteger.getAndIncrement();
    }

    public void update(){
        this.number = 10;
    }
}
```

### 多线程单例模式

```java
public class SingletonDemo {

    private static SingletonDemo singleton = null;

    private SingletonDemo() {
        System.out.println("==== singletonDemo start =====");
    }

    public static synchronized SingletonDemo getInstance() {
        if (singleton == null) {
            singleton = new SingletonDemo();
        }
        return singleton;
    }


    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                SingletonDemo.getInstance();
            },String.valueOf(i)).start();
        }
    }
}
```

> 单例模式下使用synchronized太笨重。使用DCL模式

### DCL

> DCL：double check lock 双端检索模式。

```java
public class SingletonDemo {
    // 禁止指令重排序
    private static volatile SingletonDemo singleton = null;

    private SingletonDemo() {
        System.out.println(Thread.currentThread().getName() +" ==== singletonDemo start =====");
    }

    public static SingletonDemo getInstance() {
        if (singleton == null) {
            synchronized (SingletonDemo.class) {
                if (singleton == null) {
                    singleton = new SingletonDemo();
                }
            }
        }
        return singleton;
    }


    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                SingletonDemo.getInstance();
            }, String.valueOf(i)).start();
        }
    }
}
```

## CAS原理解析

### CAS是什么

> CAS：比较并交换。（compareAndSet的缩写）
>
> 判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。

### CAS的底层原理

> 底层采用的是自旋锁和unsafe.getAndSetInt()。

```java
/**
     * Atomically increments by one the current value.
     * @param this代表的是当前对象
     * @param valueOffset代表的是内存偏移地址
     * @param 1代表的是偏移量
     * @return the previous value
     */
    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
```

### Unsafe是什么

> 是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为java中CAS操作的执行依赖于Unsafe类的方法。
>
> Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务。

### CAS的缺点

> 1. 循环时间长开销很大。
> 2. 只能保证一个共享变量的原子操作。
> 3. 引出ABA问题。

### ABA问题

> 如果两个线程同时操作一个变量A，其中一个线程将值改成B，在另外一个线程未启动之前将值又改回成A，这是对于另外一个线程来说变量A的值是不变的。

### 解决ABA问题

> 使用AtomicStampedReference，创建时会在每个线程中添加一个版本号，如果修改值的时候，线程中的版本号落后于内存中的版本号，则此次修改作废。

## 集合类不安全问题

### ArrayList不安全案例

```java
public class ArrayListDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        for (int i = 0; i < 400; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            },"--线程"+i+"--").start();
        }
    }
}
// java.util.ConcurrentModificationException 并发修改异常
```

> 并发争抢修改导致。

### 解决方案

> 使用jdk提供的创建集合安全的工具类创建一个安全的集合：List<String> list = Collections.synchronizedList(new ArrayList<>());

### CopyOnWriteArrayList的使用

> CopyOnWriteArrayList：意思是写时复制。读写分离的思想。

> ```java
> List<String> list = new CopyOnWriteArrayList<>();
> ```

## java的锁机制

### 公平锁与非公平锁

> ```java
> Lock lock = new ReentrantLock();
> ```

> 公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队等候，先来后到。
>
> 非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能在高并发的情况下后申请的线程比先申请的线程优先获得锁，造成优先级反转的现象。
>
> 区别：公平锁是按照先进先出的原则，非公平锁会直接尝试占有锁，如果尝试失败，再采用类似公平锁的方式。默认构造函数创建的事非公平锁，非公平锁的优点是比公平锁的吞吐量大。

### 可重入锁（又名递归锁）

> ReentrantLock/Synchronized

> 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
>
> 也就是说，线程可以进入任何一个它已经拥有的锁同步这的代码块。

### 递归锁案例

```java 
package com.example.ribbon_customer.demo;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockDemo {

    public static void main(String[] args) {
        Lock lock = new ReentrantLock();

        Phone phone=new Phone();

        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                phone.sendSMS();
            },"线程："+i).start();
        }

    }
}


class Phone {

    public synchronized void sendSMS(){
        System.out.println(Thread.currentThread().getName()+"==== senSMS ====");
        sendEmail();
    }

    public synchronized void sendEmail(){
        System.out.println(Thread.currentThread().getName()+"***** sendEmail ******");
    }

}
```

